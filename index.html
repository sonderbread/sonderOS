<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SonderOS - Materials Management System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #00ffff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #00ffff;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 0 0 20px #00ffff;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { text-shadow: 0 0 20px #00ffff; }
            to { text-shadow: 0 0 30px #00ffff, 0 0 40px #00ffff; }
        }

        .input-section {
            background: rgba(0, 100, 100, 0.1);
            border: 1px solid #006666;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .paste-area {
            width: 100%;
            height: 200px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ffff;
            border-radius: 8px;
            color: #00ffff;
            padding: 15px;
            font-family: monospace;
            font-size: 14px;
            resize: vertical;
            margin-bottom: 15px;
        }

        .paste-area:focus {
            outline: none;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }

        .paste-area::placeholder {
            color: rgba(0, 255, 255, 0.5);
        }

        .cargo-capacity-section {
            background: rgba(0, 255, 255, 0.05);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .cargo-label {
            color: #00ffff;
            font-weight: bold;
            font-size: 14px;
        }

        .cargo-input {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 10px 15px;
            border-radius: 6px;
            width: 150px;
            text-align: center;
            font-size: 16px;
            font-weight: bold;
        }

        .cargo-input:focus {
            outline: none;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .cargo-hint {
            color: rgba(0, 255, 255, 0.6);
            font-size: 12px;
            font-style: italic;
        }

        .cargo-btn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            border: none;
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s ease;
            margin-left: 8px;
            min-width: 80px;
        }

        .cargo-btn:hover {
            background: linear-gradient(45deg, #45a049, #4CAF50);
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.5);
            transform: translateY(-1px);
        }

        .cargo-btn:disabled {
            background: linear-gradient(45deg, #333, #666);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .sample-format {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
            font-family: monospace;
            font-size: 12px;
            color: rgba(0, 255, 255, 0.7);
        }

        .controls-section {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
        }

        .scrubber-btn {
            background: linear-gradient(45deg, #ff6600, #ffaa00);
            border: none;
            color: white;
            padding: 15px 30px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.3s ease;
            min-width: 200px;
        }

        .scrubber-btn:hover {
            background: linear-gradient(45deg, #ffaa00, #ffdd00);
            box-shadow: 0 0 20px rgba(255, 170, 0, 0.5);
            transform: translateY(-2px);
        }

        .scrubber-btn.active {
            background: linear-gradient(45deg, #00cc00, #00ff00);
            animation: pulse 1s infinite;
        }

        .scrubber-btn:disabled {
            background: linear-gradient(45deg, #333, #666);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 20px rgba(0, 255, 0, 0.5); }
            50% { box-shadow: 0 0 30px rgba(0, 255, 0, 0.8); }
            100% { box-shadow: 0 0 20px rgba(0, 255, 0, 0.5); }
        }

        .confirm-btn {
            background: linear-gradient(45deg, #006666, #00cccc);
            border: none;
            color: white;
            padding: 15px 30px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.3s ease;
            min-width: 200px;
        }

        .confirm-btn:hover {
            background: linear-gradient(45deg, #00cccc, #00ffff);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            transform: translateY(-2px);
        }

        .confirm-btn:disabled {
            background: linear-gradient(45deg, #333, #666);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .stats-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #00ffff;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 12px;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .materials-section {
            margin-bottom: 30px;
        }

        .materials-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 15px;
        }

        .material-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            margin-bottom: 8px;
            background: rgba(0, 255, 255, 0.05);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 6px;
            transition: all 0.3s ease;
        }

        .material-item:hover {
            background: rgba(0, 255, 255, 0.1);
            border-color: #00ffff;
        }

        .material-item.complete {
            border-left: 4px solid #00ff00;
            background: rgba(0, 255, 0, 0.1);
        }

        .material-item.partial {
            border-left: 4px solid #ffaa00;
        }

        .material-item.needed {
            border-left: 4px solid #ff4444;
        }

        .material-name {
            flex: 1;
            font-weight: bold;
            font-size: 14px;
        }

        .material-progress {
            color: #ffaa00;
            margin: 0 15px;
            min-width: 120px;
            font-size: 12px;
            text-align: center;
        }

        .material-input {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 8px 12px;
            border-radius: 4px;
            width: 80px;
            text-align: center;
            font-size: 14px;
        }

        .material-input:focus {
            outline: none;
            box-shadow: 0 0 8px rgba(0, 255, 255, 0.5);
        }

        .status-indicator {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-left: 10px;
            transition: all 0.3s ease;
        }

        .status-complete {
            background: #00ff00;
            box-shadow: 0 0 8px #00ff00;
        }

        .status-partial {
            background: #ffaa00;
            box-shadow: 0 0 8px #ffaa00;
        }

        .status-needed {
            background: #ff4444;
            box-shadow: 0 0 8px #ff4444;
        }

        .log-section {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid #00ffff;
            border-radius: 10px;
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
        }

        .log-entry {
            padding: 8px 12px;
            margin-bottom: 4px;
            background: rgba(0, 255, 255, 0.05);
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            border-left: 3px solid #00ffff;
        }

        .log-entry.warning {
            border-left-color: #ffaa00;
            background: rgba(255, 170, 0, 0.05);
        }

        .log-entry.success {
            border-left-color: #00ff00;
            background: rgba(0, 255, 0, 0.05);
        }

        .log-entry.allocation {
            border-left-color: #ff00ff;
            background: rgba(255, 0, 255, 0.05);
        }

        .action-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
        }

        .btn {
            background: linear-gradient(45deg, #666, #999);
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: linear-gradient(45deg, #999, #ccc);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        .hidden {
            display: none;
        }

        .footer {
            margin-top: 40px;
            padding: 20px;
            text-align: center;
            background: rgba(0, 255, 255, 0.05);
            border-top: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px 10px 0 0;
            font-size: 14px;
            color: rgba(0, 255, 255, 0.8);
            line-height: 1.5;
        }

        .footer a {
            color: #00ffff;
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .footer a:hover {
            color: #ffffff;
            text-shadow: 0 0 10px #00ffff;
        }

        .footer .license-text {
            margin-top: 8px;
            font-size: 12px;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>SonderOS Materials Management</h1>
            <p>Advanced Resource Allocation & Tracking System v2.1</p>
        </div>

        <div class="input-section" id="inputSection">
            <h3>Paste SonderOS Commodities List</h3>
            <textarea class="paste-area" id="commoditiesPaste" placeholder="Paste your commodities list here...

✓ Discord Ticket Format (full ticket paste)
✓ Simple formats like:
Steel Plates: 100
Copper Wire: 250
Circuit Boards: 50

The scrubber will automatically detect and parse your format!"></textarea>
            
            <div class="cargo-capacity-section">
                <label for="cargoCapacity" class="cargo-label">Your Ship's Cargo Capacity (tons):</label>
                <input type="number" id="cargoCapacity" class="cargo-input" placeholder="e.g., 500" min="1" max="10000" oninput="saveCargoCapacity()">
                <div class="cargo-hint">This will be saved for future sessions</div>
            </div>
            
            <div class="sample-format">
                <strong>Auto-detected formats:</strong><br>
                • <strong>Discord Tickets</strong> - Full ticket paste with ITEMS section<br>
                • Material Name: Quantity <em>or</em> Quantity: Material Name<br>
                • Material Name, Quantity <em>or</em> Quantity, Material Name<br>
                • Material Name - Quantity <em>or</em> Quantity - Material Name<br>
                • Material Name | Quantity <em>or</em> Quantity | Material Name<br>
                • Material Name [tab] Quantity <em>or</em> Quantity [tab] Material Name<br>
                <br><strong>Quantity formats supported:</strong><br>
                • Plain numbers: 784, 1,250<br>
                • With tons suffix: 784t, 784T, 784 tons, 784 Tons
            </div>
        </div>

        <div class="controls-section">
            <button class="scrubber-btn" id="scrubberBtn" onclick="runDataScrubber()">
                <span id="scrubber-text">SCRUB & PARSE DATA</span>
            </button>
            <button class="confirm-btn" id="confirmBtn" onclick="finalizeSession()" disabled>
                FINALIZE SESSION
            </button>
        </div>

        <div class="stats-section" id="statsSection" style="display: none;">
            <div class="stat-card">
                <div class="stat-value" id="totalItems">0</div>
                <div class="stat-label">Total Materials</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="totalNeeded">0</div>
                <div class="stat-label">Total Needed</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="totalAllocated">0</div>
                <div class="stat-label">Total Allocated</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="completionRate">0%</div>
                <div class="stat-label">Completion Rate</div>
            </div>
        </div>

        <div class="materials-section" id="materialsSection" style="display: none;">
            <h3>Materials Tracking</h3>
            <div class="materials-grid" id="materialsGrid"></div>
        </div>

        <div class="action-buttons" id="actionButtons" style="display: none;">
            <button class="btn" onclick="clearSession()">Clear Session</button>
            <button class="btn" onclick="exportData()">Export Data</button>
            <button class="btn" onclick="clearSavedData()">Clear Saved Data</button>
        </div>

        <div class="log-section">
            <h3>System Activity Log</h3>
            <div id="activityLog"></div>
        </div>

        <div class="footer">
            <div>
                Brought to you by <strong>CMDR Sonderbread</strong> of <strong>F.R.E.I.G.H.T.</strong> 
                • <a href="https://discord.gg/freight" target="_blank">discord.gg/freight</a>
            </div>
            <div class="license-text">
                Licensed for free use • Not for hosting or commercial modification without permission
            </div>
        </div>
    </div>

    <script>
        let materials = [];
        let activityLog = [];
        let scrubberActive = false;
        let sessionActive = false;
        let cargoCapacity = 0;

        // Auto-save functionality
        function saveState() {
            const state = {
                materials: materials,
                activityLog: activityLog,
                sessionActive: sessionActive,
                cargoCapacity: cargoCapacity,
                timestamp: new Date().toISOString()
            };
            localStorage.setItem('sonderOS_state', JSON.stringify(state));
        }

        function loadState() {
            try {
                const savedState = localStorage.getItem('sonderOS_state');
                if (savedState) {
                    const state = JSON.parse(savedState);
                    
                    materials = state.materials || [];
                    activityLog = state.activityLog || [];
                    sessionActive = state.sessionActive || false;
                    cargoCapacity = state.cargoCapacity || 0;
                    
                    // Restore cargo capacity in UI
                    if (cargoCapacity > 0) {
                        document.getElementById('cargoCapacity').value = cargoCapacity;
                    }
                    
                    if (materials.length > 0 && sessionActive) {
                        // Restore UI to active session state
                        document.getElementById('inputSection').style.display = 'none';
                        document.getElementById('statsSection').style.display = 'grid';
                        document.getElementById('materialsSection').style.display = 'block';
                        document.getElementById('actionButtons').style.display = 'flex';
                        document.getElementById('confirmBtn').disabled = false;
                        document.getElementById('scrubber-text').textContent = 'SCRUB COMPLETE';
                        
                        renderMaterials();
                        updateStats();
                        renderActivityLog();
                        
                        const savedTime = new Date(state.timestamp).toLocaleString();
                        logActivity(`Previous session restored from ${savedTime}`, 'success');
                        logActivity(`Restored ${materials.length} materials with ongoing allocations`, 'info');
                        
                        if (cargoCapacity > 0) {
                            logActivity(`Cargo capacity: ${cargoCapacity} tons`, 'info');
                        }
                        
                        return true;
                    }
                }
            } catch (e) {
                console.error('Error loading saved state:', e);
                localStorage.removeItem('sonderOS_state');
            }
            return false;
        }

        function clearSavedState() {
            localStorage.removeItem('sonderOS_state');
            logActivity('Saved browser data cleared', 'info');
        }

        function saveCargoCapacity() {
            const input = document.getElementById('cargoCapacity');
            cargoCapacity = parseInt(input.value) || 0;
            
            // Save just the cargo capacity immediately
            const existingState = JSON.parse(localStorage.getItem('sonderOS_state') || '{}');
            existingState.cargoCapacity = cargoCapacity;
            localStorage.setItem('sonderOS_state', JSON.stringify(existingState));
            
            if (cargoCapacity > 0) {
                logActivity(`Cargo capacity set to ${cargoCapacity} tons`, 'info');
            }
        }

        function renderActivityLog() {
            const logContainer = document.getElementById('activityLog');
            logContainer.innerHTML = '';
            
            activityLog.forEach(entry => {
                const logDiv = document.createElement('div');
                logDiv.className = `log-entry ${entry.type}`;
                logDiv.textContent = entry.message;
                logContainer.appendChild(logDiv);
            });
        }

        function logActivity(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] ${message}`;
            
            activityLog.unshift({ message: logEntry, type });
            if (activityLog.length > 100) {
                activityLog = activityLog.slice(0, 100);
            }
            
            renderActivityLog();
            
            // Auto-save state after logging activity
            if (sessionActive) {
                saveState();
            }
        }

        function runDataScrubber() {
            const pasteArea = document.getElementById('commoditiesPaste');
            const rawData = pasteArea.value.trim();
            
            if (!rawData) {
                logActivity('Error: No data to scrub. Please paste commodities list first.', 'warning');
                return;
            }
            
            if (scrubberActive) return;
            
            scrubberActive = true;
            const scrubberBtn = document.getElementById('scrubberBtn');
            const scrubberText = document.getElementById('scrubber-text');
            
            scrubberBtn.classList.add('active');
            scrubberText.textContent = 'SCRUBBING DATA...';
            scrubberBtn.disabled = true;
            
            logActivity('Data scrubber initiated - parsing commodities list', 'info');
            
            // Simulate scrubbing process with progress
            let progress = 0;
            const scrubberInterval = setInterval(() => {
                progress += 25;
                scrubberText.textContent = `SCRUBBING... ${progress}%`;
                
                if (progress >= 100) {
                    clearInterval(scrubberInterval);
                    
                    // Parse the data
                    const parsedMaterials = parseRawData(rawData);
                    
                    if (parsedMaterials.length > 0) {
                        materials = parsedMaterials;
                        sessionActive = true;
                        
                        // Save state immediately after parsing completes
                        saveState();
                        
                        scrubberText.textContent = 'SCRUB COMPLETE';
                        scrubberBtn.classList.remove('active');
                        
                        // Show materials section
                        document.getElementById('statsSection').style.display = 'grid';
                        document.getElementById('materialsSection').style.display = 'block';
                        document.getElementById('actionButtons').style.display = 'flex';
                        document.getElementById('confirmBtn').disabled = false;
                        
                        renderMaterials();
                        updateStats();
                        
                        logActivity(`Successfully parsed ${materials.length} materials from input`, 'success');
                        logActivity(`Session auto-saved to browser storage`, 'info');
                        
                        // Hide input section
                        document.getElementById('inputSection').style.display = 'none';
                        
                    } else {
                        scrubberText.textContent = 'SCRUB FAILED';
                        logActivity('Error: Could not parse any valid materials from input', 'warning');
                        
                        setTimeout(() => {
                            scrubberText.textContent = 'SCRUB & PARSE DATA';
                            scrubberBtn.disabled = false;
                            scrubberActive = false;
                        }, 2000);
                    }
                }
            }, 500);
        }

        function parseRawData(rawData) {
            // Check if this is a Discord ticket format
            if (rawData.includes('ITEMS:') || rawData.includes('CONTRACT:')) {
                return parseDiscordTicket(rawData);
            }
            
            // Check for 3-column pipe format (Item | Qty | Price)
            if (rawData.includes('|') && (rawData.includes('Qty') || rawData.includes('Buy Price'))) {
                return parseThreeColumnFormat(rawData);
            }
            
            // Original parsing for other formats
            const lines = rawData.split('\n').map(line => line.trim()).filter(line => line);
            const parsedMaterials = [];
            let id = 1;
            
            for (const line of lines) {
                // Try different separator patterns
                let match = null;
                let name = '';
                let quantity = 0;
                
                // Helper function to extract quantity from string with optional t/tons suffix
                function parseQuantity(quantityStr) {
                    const cleanStr = quantityStr.replace(/,/g, ''); // Remove commas
                    const quantityMatch = cleanStr.match(/^(\d+)(?:\s*[tT](?:ons?)?)?$/);
                    return quantityMatch ? parseInt(quantityMatch[1]) : 0;
                }
                
                // Pattern 1: Name: Quantity (with optional t/tons)
                match = line.match(/^(.+?):\s*(\d+(?:,\d{3})*(?:\s*[tT](?:ons?)?)?)$/);
                if (match) {
                    name = match[1].trim();
                    quantity = parseQuantity(match[2]);
                } else {
                    // Pattern 1b: Quantity: Name (reversed)
                    match = line.match(/^(\d+(?:,\d{3})*(?:\s*[tT](?:ons?)?)?)\s*:\s*(.+)$/);
                    if (match) {
                        quantity = parseQuantity(match[1]);
                        name = match[2].trim();
                    }
                }
                
                if (!match) {
                    // Pattern 2: Name, Quantity (with optional t/tons)
                    match = line.match(/^(.+?),\s*(\d+(?:,\d{3})*(?:\s*[tT](?:ons?)?)?)$/);
                    if (match) {
                        name = match[1].trim();
                        quantity = parseQuantity(match[2]);
                    } else {
                        // Pattern 2b: Quantity, Name (reversed)
                        match = line.match(/^(\d+(?:,\d{3})*(?:\s*[tT](?:ons?)?)?)\s*,\s*(.+)$/);
                        if (match) {
                            quantity = parseQuantity(match[1]);
                            name = match[2].trim();
                        }
                    }
                }
                
                if (!match) {
                    // Pattern 3: Name - Quantity (with optional t/tons)
                    match = line.match(/^(.+?)\s*-\s*(\d+(?:,\d{3})*(?:\s*[tT](?:ons?)?)?)$/);
                    if (match) {
                        name = match[1].trim();
                        quantity = parseQuantity(match[2]);
                    } else {
                        // Pattern 3b: Quantity - Name (reversed)
                        match = line.match(/^(\d+(?:,\d{3})*(?:\s*[tT](?:ons?)?)?)\s*-\s*(.+)$/);
                        if (match) {
                            quantity = parseQuantity(match[1]);
                            name = match[2].trim();
                        }
                    }
                }
                
                if (!match) {
                    // Pattern 4: Name | Quantity (2-column only, with optional t/tons)
                    match = line.match(/^(.+?)\s*\|\s*(\d+(?:,\d{3})*(?:\s*[tT](?:ons?)?)?)$/);
                    if (match) {
                        name = match[1].trim();
                        quantity = parseQuantity(match[2]);
                    } else {
                        // Pattern 4b: Quantity | Name (reversed)
                        match = line.match(/^(\d+(?:,\d{3})*(?:\s*[tT](?:ons?)?)?)\s*\|\s*(.+)$/);
                        if (match) {
                            quantity = parseQuantity(match[1]);
                            name = match[2].trim();
                        }
                    }
                }
                
                if (!match) {
                    // Pattern 5: Name [tab] Quantity (with optional t/tons)
                    match = line.match(/^(.+?)\t+(\d+(?:,\d{3})*(?:\s*[tT](?:ons?)?)?)$/);
                    if (match) {
                        name = match[1].trim();
                        quantity = parseQuantity(match[2]);
                    } else {
                        // Pattern 5b: Quantity [tab] Name (reversed)
                        match = line.match(/^(\d+(?:,\d{3})*(?:\s*[tT](?:ons?)?)?)\t+(.+)$/);
                        if (match) {
                            quantity = parseQuantity(match[1]);
                            name = match[2].trim();
                        }
                    }
                }
                
                if (!match) {
                    // Pattern 6: Name [multiple spaces] Quantity (with optional t/tons)
                    match = line.match(/^(.+?)\s{2,}(\d+(?:,\d{3})*(?:\s*[tT](?:ons?)?)?)$/);
                    if (match) {
                        name = match[1].trim();
                        quantity = parseQuantity(match[2]);
                    } else {
                        // Pattern 6b: Quantity [multiple spaces] Name (reversed)
                        match = line.match(/^(\d+(?:,\d{3})*(?:\s*[tT](?:ons?)?)?)\s{2,}(.+)$/);
                        if (match) {
                            quantity = parseQuantity(match[1]);
                            name = match[2].trim();
                        }
                    }
                }
                
                if (!match) {
                    // Pattern 7: Name [single space] Quantity (with optional t/tons)
                    match = line.match(/^(.+?)\s+(\d+(?:,\d{3})*(?:\s*[tT](?:ons?)?)?)$/);
                    if (match) {
                        name = match[1].trim();
                        quantity = parseQuantity(match[2]);
                    } else {
                        // Pattern 7b: Quantity [single space] Name (reversed) - THIS HANDLES "100t cmm composite"
                        match = line.match(/^(\d+(?:,\d{3})*(?:\s*[tT](?:ons?)?)?)\s+(.+)$/);
                        if (match) {
                            quantity = parseQuantity(match[1]);
                            name = match[2].trim();
                        }
                    }
                }
                
                if (match && name && quantity > 0) {
                    parsedMaterials.push({
                        id: id++,
                        name: name,
                        needed: quantity,
                        original: quantity,
                        allocated: 0
                    });
                    
                    logActivity(`Parsed: ${name} (${quantity} needed)`, 'info');
                } else {
                    logActivity(`Warning: Could not parse line: "${line}"`, 'warning');
                }
            }
            
            return parsedMaterials;
        }

        function parseThreeColumnFormat(rawData) {
            const lines = rawData.split('\n').map(line => line.trim()).filter(line => line);
            const parsedMaterials = [];
            let id = 1;
            
            logActivity('Detected 3-column pipe format (Item | Qty | Price)', 'info');
            
            for (const line of lines) {
                // Skip header lines, separators, and category lines
                if (line.includes('Item') && line.includes('Qty') ||
                    line.includes('---') ||
                    line.includes('===') ||
                    line.startsWith('=') ||
                    line.trim() === '') {
                    continue;
                }
                
                // Parse 3-column format: "Item Name | Quantity | Price"
                const match = line.match(/^(.+?)\s*\|\s*([0-9,]+)\s*\|\s*([0-9,]+)$/);
                
                if (match) {
                    const name = match[1].trim();
                    const quantity = parseInt(match[2].replace(/,/g, ''));
                    const price = parseInt(match[3].replace(/,/g, ''));
                    
                    if (name && quantity > 0) {
                        parsedMaterials.push({
                            id: id++,
                            name: name,
                            needed: quantity,
                            original: quantity,
                            allocated: 0
                        });
                        
                        logActivity(`Parsed: ${name} (${quantity} needed @ ${price} credits)`, 'info');
                    }
                } else {
                    // Only log non-empty lines that don't match
                    if (line.length > 0) {
                        logActivity(`Skipped line: "${line}"`, 'warning');
                    }
                }
            }
            
            if (parsedMaterials.length > 0) {
                logActivity(`Successfully parsed ${parsedMaterials.length} items from 3-column format`, 'success');
            }
            
            return parsedMaterials;
        }

        function parseDiscordTicket(rawData) {
            const lines = rawData.split('\n');
            const parsedMaterials = [];
            let id = 1;
            let inItemsSection = false;
            let contractInfo = {};
            
            // Extract contract info
            for (const line of lines) {
                if (line.includes('CONTRACT:')) {
                    contractInfo.contract = line.split(':')[1]?.trim();
                } else if (line.includes('System:')) {
                    contractInfo.system = line.split(':')[1]?.trim();
                } else if (line.includes('Order:')) {
                    contractInfo.order = line.split(':')[1]?.trim();
                } else if (line.includes('Total Tonnage:')) {
                    contractInfo.tonnage = line.split(':')[1]?.trim();
                }
            }
            
            // Log contract info
            if (contractInfo.contract) {
                logActivity(`Processing ticket: ${contractInfo.contract}`, 'info');
                if (contractInfo.system) logActivity(`System: ${contractInfo.system}`, 'info');
                if (contractInfo.order) logActivity(`Order: ${contractInfo.order}`, 'info');
                if (contractInfo.tonnage) logActivity(`Total Tonnage: ${contractInfo.tonnage}`, 'info');
            }
            
            for (const line of lines) {
                // Start parsing items after "ITEMS:" line
                if (line.includes('ITEMS:')) {
                    inItemsSection = true;
                    continue;
                }
                
                // Skip header lines and separators
                if (!inItemsSection || 
                    line.includes('Item') || 
                    line.includes('---') || 
                    line.includes('===') ||
                    line.trim() === '') {
                    continue;
                }
                
                // Parse item lines with format: "Item Name                |    Qty |  Price"
                const itemMatch = line.match(/^(.+?)\s*\|\s*([0-9,]+)\s*\|\s*[\d,]+$/);
                
                if (itemMatch) {
                    const name = itemMatch[1].trim();
                    const quantity = parseInt(itemMatch[2].replace(/,/g, ''));
                    
                    if (name && quantity > 0) {
                        parsedMaterials.push({
                            id: id++,
                            name: name,
                            needed: quantity,
                            original: quantity,
                            allocated: 0
                        });
                        
                        logActivity(`Parsed: ${name} (${quantity} needed)`, 'info');
                    }
                }
            }
            
            if (parsedMaterials.length > 0) {
                logActivity(`Successfully parsed ${parsedMaterials.length} items from Discord ticket`, 'success');
            }
            
            return parsedMaterials;
        }

        function renderMaterials() {
            const grid = document.getElementById('materialsGrid');
            grid.innerHTML = '';
            
            materials.forEach(material => {
                const remaining = material.needed;
                const status = remaining <= 0 ? 'complete' : 
                              material.allocated > 0 ? 'partial' : 'needed';
                
                const itemDiv = document.createElement('div');
                itemDiv.className = `material-item ${status}`;
                
                // Determine cargo button allocation amount and text
                const cargoAllocation = Math.min(cargoCapacity, remaining);
                const cargoButtonDisabled = cargoCapacity <= 0 || remaining <= 0;
                const cargoButtonText = cargoCapacity > 0 ? `${cargoAllocation}T` : 'Set Cargo';
                
                itemDiv.innerHTML = `
                    <div class="material-name">${material.name}</div>
                    <div class="material-progress">
                        Need: ${material.needed}<br>
                        Allocated: ${material.allocated}
                    </div>
                    <input type="number" class="material-input" 
                           value="0" min="0" max="${remaining}"
                           onkeypress="handleEnterKey(event, ${material.id}, this)"
                           placeholder="0">
                    <button class="cargo-btn" ${cargoButtonDisabled ? 'disabled' : ''} 
                            onclick="allocateCargoCapacity(${material.id})">${cargoButtonText}</button>
                    <div class="status-indicator status-${status}"></div>
                `;
                
                grid.appendChild(itemDiv);
            });
        }

        function allocateCargoCapacity(materialId) {
            if (cargoCapacity <= 0) {
                logActivity('Error: Set your cargo capacity first', 'warning');
                return;
            }
            
            const material = materials.find(m => m.id === materialId);
            if (!material) return;
            
            const allocatable = Math.min(cargoCapacity, material.needed);
            
            if (allocatable <= 0) {
                logActivity(`${material.name} already fully allocated`, 'warning');
                return;
            }
            
            // Allocate the cargo capacity amount
            material.needed -= allocatable;
            material.allocated += allocatable;
            
            // Log the allocation
            logActivity(`Full cargo load: ${allocatable}T ${material.name} (Remaining: ${material.needed})`, 'allocation');
            
            // Re-render and update stats
            renderMaterials();
            updateStats();
            
            // Auto-save state after allocation
            saveState();
            
            // Check if material is complete
            if (material.needed <= 0) {
                logActivity(`✓ ${material.name} COMPLETE (${material.allocated}/${material.original})`, 'success');
            }
        }

        function handleEnterKey(event, materialId, inputElement) {
            if (event.key === 'Enter') {
                const quantity = parseInt(inputElement.value) || 0;
                
                if (quantity > 0) {
                    allocateMaterial(materialId, quantity);
                    inputElement.value = '0';
                    inputElement.focus();
                }
            }
        }

        function allocateMaterial(materialId, quantity) {
            const material = materials.find(m => m.id === materialId);
            if (!material) return;
            
            const allocatable = Math.min(quantity, material.needed);
            
            if (allocatable <= 0) {
                logActivity(`Warning: ${material.name} already fully allocated`, 'warning');
                return;
            }
            
            // Subtract from needed and add to allocated
            material.needed -= allocatable;
            material.allocated += allocatable;
            
            // Log the allocation
            logActivity(`Allocated ${allocatable} ${material.name} (Remaining: ${material.needed})`, 'allocation');
            
            // Re-render and update stats
            renderMaterials();
            updateStats();
            
            // Auto-save state after allocation
            saveState();
            
            // Check if material is complete
            if (material.needed <= 0) {
                logActivity(`✓ ${material.name} COMPLETE (${material.allocated}/${material.original})`, 'success');
            }
        }

        function updateStats() {
            const totalItems = materials.length;
            const totalNeeded = materials.reduce((sum, m) => sum + m.needed, 0);
            const totalAllocated = materials.reduce((sum, m) => sum + m.allocated, 0);
            const completedItems = materials.filter(m => m.needed <= 0).length;
            const completionRate = totalItems > 0 ? Math.round((completedItems / totalItems) * 100) : 0;

            document.getElementById('totalItems').textContent = totalItems;
            document.getElementById('totalNeeded').textContent = totalNeeded;
            document.getElementById('totalAllocated').textContent = totalAllocated;
            document.getElementById('completionRate').textContent = completionRate + '%';
        }

        function finalizeSession() {
            if (!sessionActive) return;
            
            const completedCount = materials.filter(m => m.needed <= 0).length;
            const totalCount = materials.length;
            
            if (confirm(`Finalize this session?\n\nCompleted: ${completedCount}/${totalCount} materials\n\nThis will save the current state and reset for a new session.`)) {
                
                // Log final session summary
                logActivity(`=== SESSION FINALIZED ===`, 'success');
                logActivity(`Completed materials: ${completedCount}/${totalCount}`, 'success');
                
                materials.forEach(material => {
                    if (material.allocated > 0) {
                        logActivity(`Final: ${material.name} - ${material.allocated}/${material.original} allocated`, 'info');
                    }
                });
                
                logActivity(`=== SESSION END ===`, 'success');
                
                // Reset for new session
                setTimeout(() => {
                    clearSession();
                }, 2000);
            }
        }

        function clearSession() {
            materials = [];
            sessionActive = false;
            
            // Save current cargo capacity before clearing state
            const currentCargoCapacity = cargoCapacity;
            
            // Clear saved state but preserve cargo capacity
            const state = {
                materials: [],
                activityLog: [],
                sessionActive: false,
                cargoCapacity: currentCargoCapacity,
                timestamp: new Date().toISOString()
            };
            localStorage.setItem('sonderOS_state', JSON.stringify(state));
            
            // Reset UI
            document.getElementById('commoditiesPaste').value = '';
            document.getElementById('inputSection').style.display = 'block';
            document.getElementById('statsSection').style.display = 'none';
            document.getElementById('materialsSection').style.display = 'none';
            document.getElementById('actionButtons').style.display = 'none';
            
            // Reset buttons
            document.getElementById('scrubberBtn').disabled = false;
            document.getElementById('confirmBtn').disabled = true;
            document.getElementById('scrubber-text').textContent = 'SCRUB & PARSE DATA';
            
            scrubberActive = false;
            
            logActivity('Session cleared - ready for new commodities list', 'info');
            if (currentCargoCapacity > 0) {
                logActivity(`Cargo capacity preserved: ${currentCargoCapacity} tons`, 'info');
            }
        }

        function clearSavedData() {
            if (confirm('Clear all saved browser data?\n\nThis will permanently remove your saved session and activity log from this browser.')) {
                clearSavedState();
                logActivity('All saved browser data has been cleared', 'success');
            }
        }

        function exportData() {
            const data = {
                timestamp: new Date().toISOString(),
                sessionSummary: {
                    totalMaterials: materials.length,
                    completedMaterials: materials.filter(m => m.needed <= 0).length,
                    totalAllocated: materials.reduce((sum, m) => sum + m.allocated, 0),
                    totalOriginal: materials.reduce((sum, m) => sum + m.original, 0)
                },
                materials: materials,
                activityLog: activityLog
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `sonderOS_session_${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            logActivity('Session data exported successfully', 'success');
        }

        // Initialize
        logActivity('SonderOS Materials Management System initialized', 'info');
        
        // Try to restore previous session
        const restored = loadState();
        if (!restored) {
            // Even if no session restored, try to load cargo capacity
            try {
                const savedState = localStorage.getItem('sonderOS_state');
                if (savedState) {
                    const state = JSON.parse(savedState);
                    if (state.cargoCapacity > 0) {
                        cargoCapacity = state.cargoCapacity;
                        document.getElementById('cargoCapacity').value = cargoCapacity;
                        logActivity(`Cargo capacity loaded: ${cargoCapacity} tons`, 'info');
                    }
                }
            } catch (e) {
                console.error('Error loading cargo capacity:', e);
            }
            
            logActivity('Ready to receive commodities list for scrubbing', 'info');
        }
    </script>
</body>
</html>
