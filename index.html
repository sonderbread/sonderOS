<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SonderOS - Materials Management System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #00ffff;
            min-height: 100vh;
            overflow-x: hidden;
        }



        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Tab System Styles */
        .tabs-container {
            margin-bottom: 20px;
            border-bottom: 2px solid rgba(0, 255, 255, 0.3);
        }

        .tabs-header {
            display: flex;
            align-items: center;
            gap: 5px;
            overflow-x: auto;
            padding-bottom: 2px;
        }

        .tab {
            background: rgba(0, 100, 100, 0.2);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-bottom: none;
            color: rgba(0, 255, 255, 0.7);
            padding: 12px 20px;
            cursor: pointer;
            border-radius: 8px 8px 0 0;
            transition: all 0.3s ease;
            white-space: nowrap;
            min-width: 120px;
            display: flex;
            align-items: center;
            gap: 8px;
            position: relative;
        }

        .tab:hover {
            background: rgba(0, 150, 150, 0.3);
            color: #00ffff;
        }

        .tab.active {
            background: rgba(0, 255, 255, 0.1);
            color: #00ffff;
            border-color: #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }

        .tab-close {
            background: rgba(255, 100, 100, 0.8);
            border: none;
            color: white;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s ease;
            margin-left: auto;
        }

        .tab-close:hover {
            background: rgba(255, 50, 50, 1);
            transform: scale(1.1);
        }

        .new-tab-btn {
            background: linear-gradient(45deg, #00cc00, #00ff00);
            border: none;
            color: white;
            padding: 12px 20px;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .new-tab-btn:hover {
            background: linear-gradient(45deg, #00ff00, #44ff44);
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
            transform: translateY(-1px);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #00ffff;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 0 0 20px #00ffff;
            animation: glow 2s ease-in-out infinite alternate;
        }

        .promotional-message {
            display: none;
            margin-top: 15px;
            padding: 10px;
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid rgba(0, 255, 0, 0.3);
            border-radius: 8px;
            font-size: 14px;
            color: #00ff88;
            animation: promotional-glow 3s ease-in-out infinite alternate;
        }

        .promotional-message.visible {
            display: block;
        }

        .promotional-message a {
            color: #00ffff;
            text-decoration: none;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .promotional-message a:hover {
            color: #ffffff;
            text-shadow: 0 0 10px #00ffff;
        }

        @keyframes promotional-glow {
            from { 
                box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
                border-color: rgba(0, 255, 0, 0.3);
            }
            to { 
                box-shadow: 0 0 20px rgba(0, 255, 136, 0.6);
                border-color: rgba(0, 255, 0, 0.6);
            }
        }

        @keyframes glow {
            from { text-shadow: 0 0 20px #00ffff; }
            to { text-shadow: 0 0 30px #00ffff, 0 0 40px #00ffff; }
        }

        .input-section {
            background: rgba(0, 100, 100, 0.1);
            border: 1px solid #006666;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .paste-area {
            width: 100%;
            height: 200px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ffff;
            border-radius: 8px;
            color: #00ffff;
            padding: 15px;
            font-family: monospace;
            font-size: 14px;
            resize: vertical;
            margin-bottom: 15px;
        }

        .paste-area:focus {
            outline: none;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }

        .paste-area::placeholder {
            color: rgba(0, 255, 255, 0.5);
        }

        .cargo-capacity-section {
            background: rgba(0, 255, 255, 0.05);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .cargo-label {
            color: #00ffff;
            font-weight: bold;
            font-size: 14px;
        }

        .cargo-input {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 10px 15px;
            border-radius: 6px;
            width: 150px;
            text-align: center;
            font-size: 16px;
            font-weight: bold;
        }

        .cargo-input:focus {
            outline: none;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .cargo-hint {
            color: rgba(0, 255, 255, 0.6);
            font-size: 12px;
            font-style: italic;
        }

        .job-name-section {
            background: rgba(0, 255, 255, 0.05);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .job-name-input {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 10px 15px;
            border-radius: 6px;
            flex: 1;
            min-width: 250px;
            font-size: 16px;
            font-weight: bold;
        }

        .job-name-input:focus {
            outline: none;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .cargo-btn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            border: none;
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s ease;
            margin-left: 8px;
            min-width: 80px;
        }

        .cargo-btn:hover {
            background: linear-gradient(45deg, #45a049, #4CAF50);
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.5);
            transform: translateY(-1px);
        }

        .cargo-btn:disabled {
            background: linear-gradient(45deg, #333, #666);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .sample-format {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
            font-family: monospace;
            font-size: 12px;
            color: rgba(0, 255, 255, 0.7);
        }

        .controls-section {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
        }

        .scrubber-btn {
            background: linear-gradient(45deg, #ff6600, #ffaa00);
            border: none;
            color: white;
            padding: 15px 30px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.3s ease;
            min-width: 200px;
        }

        .scrubber-btn:hover {
            background: linear-gradient(45deg, #ffaa00, #ffdd00);
            box-shadow: 0 0 20px rgba(255, 170, 0, 0.5);
            transform: translateY(-2px);
        }

        .scrubber-btn.active {
            background: linear-gradient(45deg, #00cc00, #00ff00);
            animation: pulse 1s infinite;
        }

        .scrubber-btn:disabled {
            background: linear-gradient(45deg, #333, #666);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 20px rgba(0, 255, 0, 0.5); }
            50% { box-shadow: 0 0 30px rgba(0, 255, 0, 0.8); }
            100% { box-shadow: 0 0 20px rgba(0, 255, 0, 0.5); }
        }

        .confirm-btn {
            background: linear-gradient(45deg, #006666, #00cccc);
            border: none;
            color: white;
            padding: 15px 30px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.3s ease;
            min-width: 200px;
        }

        .confirm-btn:hover {
            background: linear-gradient(45deg, #00cccc, #00ffff);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            transform: translateY(-2px);
        }

        .confirm-btn:disabled {
            background: linear-gradient(45deg, #333, #666);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .stats-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #00ffff;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 12px;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .materials-section {
            margin-bottom: 30px;
        }

        .materials-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
            gap: 15px;
        }

        .material-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            margin-bottom: 8px;
            background: rgba(0, 255, 255, 0.05);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 6px;
            transition: all 0.3s ease;
        }

        .material-item:hover {
            background: rgba(0, 255, 255, 0.1);
            border-color: #00ffff;
        }

        .material-item.complete {
            border-left: 4px solid #00ff00;
            background: rgba(0, 255, 0, 0.1);
        }

        .material-item.partial {
            border-left: 4px solid #ffaa00;
        }

        .material-item.needed {
            border-left: 4px solid #ff4444;
        }

        .material-name {
            flex: 1;
            font-weight: bold;
            font-size: 14px;
        }

        .material-progress {
            color: #ffaa00;
            margin: 0 15px;
            min-width: 120px;
            font-size: 12px;
            text-align: center;
        }

        .material-input {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 8px 12px;
            border-radius: 4px;
            width: 80px;
            text-align: center;
            font-size: 14px;
        }

        .material-input:focus {
            outline: none;
            box-shadow: 0 0 8px rgba(0, 255, 255, 0.5);
        }

        .material-controls {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .undo-btn {
            background: linear-gradient(45deg, #ff6600, #ff9900);
            border: none;
            color: white;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s ease;
            min-width: 60px;
        }

        .undo-btn:hover {
            background: linear-gradient(45deg, #ff9900, #ffcc00);
            box-shadow: 0 0 8px rgba(255, 153, 0, 0.5);
            transform: translateY(-1px);
        }

        .undo-btn:disabled {
            background: linear-gradient(45deg, #333, #666);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .status-indicator {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-left: 10px;
            transition: all 0.3s ease;
        }

        .status-complete {
            background: #00ff00;
            box-shadow: 0 0 8px #00ff00;
        }

        .status-partial {
            background: #ffaa00;
            box-shadow: 0 0 8px #ffaa00;
        }

        .status-needed {
            background: #ff4444;
            box-shadow: 0 0 8px #ff4444;
        }

        .log-section {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid #00ffff;
            border-radius: 10px;
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
        }

        .log-entry {
            padding: 8px 12px;
            margin-bottom: 4px;
            background: rgba(0, 255, 255, 0.05);
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            border-left: 3px solid #00ffff;
        }

        .log-entry.warning {
            border-left-color: #ffaa00;
            background: rgba(255, 170, 0, 0.05);
        }

        .log-entry.success {
            border-left-color: #00ff00;
            background: rgba(0, 255, 0, 0.05);
        }

        .log-entry.allocation {
            border-left-color: #ff00ff;
            background: rgba(255, 0, 255, 0.05);
        }

        .log-entry.undo {
            border-left-color: #ff6600;
            background: rgba(255, 102, 0, 0.05);
        }

        .action-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
        }

        .btn {
            background: linear-gradient(45deg, #666, #999);
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: linear-gradient(45deg, #999, #ccc);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        .hidden {
            display: none;
        }

        .footer {
            margin-top: 40px;
            padding: 20px;
            text-align: center;
            background: rgba(0, 255, 255, 0.05);
            border-top: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px 10px 0 0;
            font-size: 14px;
            color: rgba(0, 255, 255, 0.8);
            line-height: 1.5;
        }

        .footer.branded {
            display: block;
        }

        .footer:not(.branded) {
            display: none;
        }

        .footer a {
            color: #00ffff;
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .footer a:hover {
            color: #ffffff;
            text-shadow: 0 0 10px #00ffff;
        }

        .footer .license-text {
            margin-top: 8px;
            font-size: 12px;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>SonderOS Materials Management</h1>
            <p>Enhanced Multi-Job Tracking System v3.2</p>
            <div class="promotional-message" id="promotionalMessage">
                This tool brought to you by <strong>F.R.E.I.G.H.T.</strong> Come let us know how you like it! 
                <a href="https://discord.gg/freight" target="_blank">discord.gg/freight</a>
            </div>
        </div>

        <!-- Tab System -->
        <div class="tabs-container">
            <div class="tabs-header" id="tabsHeader">
                <button class="new-tab-btn" onclick="createNewTab()">+ NEW JOB</button>
            </div>
        </div>

        <!-- Tab Contents Container -->
        <div id="tabContents"></div>

        <div class="footer" id="footer">
            <div>
                Brought to you by <strong>CMDR Sonderbread</strong> of <strong>F.R.E.I.G.H.T.</strong> 
                • <a href="https://discord.gg/freight" target="_blank">discord.gg/freight</a>
            </div>
            <div class="license-text">
                Licensed for free use • Not for hosting or commercial modification without permission
            </div>
        </div>
    </div>

    <script>
        let tabs = {};
        let currentTabId = null;
        let globalCargoCapacity = 0;
        let nextTabId = 1;
        let usageCount = 0;

        // Usage tracking functions
        function loadUsageCount() {
            const savedCount = localStorage.getItem('sonderOS_usage_count');
            usageCount = savedCount ? parseInt(savedCount) : 0;
            console.log('Loaded usage count:', usageCount);
            updateBrandingDisplay();
        }

        function incrementUsageCount() {
            usageCount++;
            localStorage.setItem('sonderOS_usage_count', usageCount.toString());
            console.log('Usage count incremented to:', usageCount);
            
            if (usageCount >= 15) {
                updateBrandingDisplay();
            }
        }

        function updateBrandingDisplay() {
            const promotionalMessage = document.getElementById('promotionalMessage');
            const footer = document.getElementById('footer');
            
            if (usageCount >= 15) {
                // Show promotional message
                if (promotionalMessage) {
                    promotionalMessage.classList.add('visible');
                }
                
                // Show footer
                if (footer) {
                    footer.classList.add('branded');
                }
                
                console.log('Branding activated at usage count:', usageCount);
            } else {
                // Hide promotional elements
                if (promotionalMessage) {
                    promotionalMessage.classList.remove('visible');
                }
                
                if (footer) {
                    footer.classList.remove('branded');
                }
            }
        }

        // Tab Content Template
        function createTabContentHTML(tabId) {
            return `
                <div class="tab-content" id="tab-content-${tabId}">
                    <div class="input-section" id="inputSection-${tabId}">
                        <h3>Setup New Job</h3>
                        <div class="job-name-section">
                            <label for="jobName-${tabId}" class="cargo-label">Job Name:</label>
                            <input type="text" id="jobName-${tabId}" class="job-name-input" 
                                   placeholder="Enter job name (e.g., Mining Contract Alpha)" 
                                   oninput="updateJobName(${tabId}, this.value)"
                                   maxlength="50">
                            <div class="cargo-hint">This will be displayed on the tab</div>
                        </div>
                        <h4 style="margin-top: 20px;">Paste SonderOS Commodities List</h4>
                        <textarea class="paste-area" id="commoditiesPaste-${tabId}" placeholder="Paste your commodities list here...

✓ Consolidated Contract Format (full contract paste)
✓ Discord Ticket Format (full ticket paste)
✓ Simple formats like:
Steel Plates: 100
Copper Wire: 250
Circuit Boards: 50

The scrubber will automatically detect and parse your format!"></textarea>
                        
                        <div class="cargo-capacity-section">
                            <label for="cargoCapacity-${tabId}" class="cargo-label">Your Ship's Cargo Capacity (tons):</label>
                            <input type="number" id="cargoCapacity-${tabId}" class="cargo-input" placeholder="e.g., 500" min="1" max="10000" oninput="saveCargoCapacity(${tabId})">
                            <div class="cargo-hint">This will be saved globally for all jobs</div>
                        </div>
                        
                        <div class="sample-format">
                            <strong>Auto-detected formats:</strong><br>
                            • <strong>Consolidated Contracts</strong> - Full contract paste with "ALL MATERIALS:" and categories<br>
                            • <strong>Discord Tickets</strong> - Full ticket paste with ITEMS section<br>
                            • Material Name: Quantity <em>or</em> Quantity: Material Name<br>
                            • Material Name, Quantity <em>or</em> Quantity, Material Name<br>
                            • Material Name - Quantity <em>or</em> Quantity - Material Name<br>
                            • Material Name | Quantity <em>or</em> Quantity | Material Name<br>
                            • Material Name [tab] Quantity <em>or</em> Quantity [tab] Material Name<br>
                            • Material Name [space] Quantity <em>or</em> Quantity [space] Material Name<br>
                            <br><strong>Quantity formats supported:</strong><br>
                            • Plain numbers: 784, 1250<br>
                            • With commas: 28,000<br>
                            • With periods: 28.000 (European format)<br>
                            • With k suffix: 28k, 28K (= 28,000)<br>
                            • With tons suffix: 784t, 784T, 784 tons<br>
                            • Combined: 28kt, 1.5k tons
                        </div>
                    </div>

                    <div class="controls-section">
                        <button class="scrubber-btn" id="scrubberBtn-${tabId}" onclick="runDataScrubber(${tabId})">
                            <span id="scrubber-text-${tabId}">SCRUB & PARSE DATA</span>
                        </button>
                        <button class="confirm-btn" id="confirmBtn-${tabId}" onclick="finalizeSession(${tabId})" disabled>
                            FINALIZE SESSION
                        </button>
                    </div>

                    <div class="stats-section" id="statsSection-${tabId}" style="display: none;">
                        <div class="stat-card">
                            <div class="stat-value" id="totalItems-${tabId}">0</div>
                            <div class="stat-label">Total Materials</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="totalNeeded-${tabId}">0</div>
                            <div class="stat-label">Total Needed</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="totalAllocated-${tabId}">0</div>
                            <div class="stat-label">Total Allocated</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="completionRate-${tabId}">0%</div>
                            <div class="stat-label">Completion Rate</div>
                        </div>
                    </div>

                    <div class="materials-section" id="materialsSection-${tabId}" style="display: none;">
                        <h3>Materials Tracking</h3>
                        <div class="materials-grid" id="materialsGrid-${tabId}"></div>
                    </div>

                    <div class="action-buttons" id="actionButtons-${tabId}" style="display: none;">
                        <button class="btn" onclick="clearSession(${tabId})">Clear Session</button>
                        <button class="btn" onclick="exportData(${tabId})">Export Data</button>
                    </div>

                    <div class="log-section">
                        <h3>System Activity Log</h3>
                        <div id="activityLog-${tabId}"></div>
                    </div>
                </div>
            `;
        }

        // Tab Management
        function createNewTab() {
            console.log('Creating new tab...');
            
            const tabId = nextTabId++;
            const tabName = `Job ${tabId}`;
            
            try {
                // Create tab data structure
                tabs[tabId] = {
                    id: tabId,
                    name: tabName,
                    materials: [],
                    activityLog: [],
                    sessionActive: false,
                    scrubberActive: false
                };
                
                // Create tab UI
                const tabsHeader = document.getElementById('tabsHeader');
                const newTabBtn = tabsHeader.querySelector('.new-tab-btn');
                
                if (!tabsHeader || !newTabBtn) {
                    console.error('Required elements not found:', { tabsHeader, newTabBtn });
                    return;
                }
                
                const tabElement = document.createElement('div');
                tabElement.className = 'tab';
                tabElement.id = `tab-${tabId}`;
                tabElement.innerHTML = `
                    <span id="tab-name-${tabId}">${tabName}</span>
                    <button class="tab-close" onclick="closeTab(${tabId}, event)">×</button>
                `;
                tabElement.onclick = (e) => {
                    if (e.target.className !== 'tab-close') {
                        switchToTab(tabId);
                    }
                };
                
                tabsHeader.insertBefore(tabElement, newTabBtn);
                
                // Create tab content
                const tabContents = document.getElementById('tabContents');
                if (!tabContents) {
                    console.error('tabContents element not found');
                    return;
                }
                
                tabContents.insertAdjacentHTML('beforeend', createTabContentHTML(tabId));
                
                // Wait for DOM to process the inserted HTML before switching tabs
                setTimeout(() => {
                    // Switch to new tab
                    switchToTab(tabId);
                    
                    // Set focus to job name input
                    setTimeout(() => {
                        const jobNameInput = document.getElementById(`jobName-${tabId}`);
                        if (jobNameInput) {
                            jobNameInput.focus();
                            jobNameInput.select();
                        } else {
                            console.warn('Job name input not found:', `jobName-${tabId}`);
                        }
                    }, 50);
                    
                    // Log activity
                    logActivity(tabId, `New job "${tabName}" created`, 'success');
                    saveState();
                    
                    console.log('Tab created successfully:', tabId);
                }, 10);
                
            } catch (error) {
                console.error('Error creating tab:', error);
            }
        }

        // Job Name Management
        function updateJobName(tabId, newName) {
            if (!tabs[tabId]) return;
            
            newName = newName.trim();
            if (newName === '') {
                newName = `Job ${tabId}`;
            }
            
            // Limit name length
            if (newName.length > 50) {
                newName = newName.substring(0, 50);
                document.getElementById(`jobName-${tabId}`).value = newName;
            }
            
            const oldName = tabs[tabId].name;
            tabs[tabId].name = newName;
            
            // Update tab display
            const tabNameElement = document.getElementById(`tab-name-${tabId}`);
            if (tabNameElement) {
                tabNameElement.textContent = newName;
            }
            
            if (oldName !== newName) {
                logActivity(tabId, `Job renamed from "${oldName}" to "${newName}"`, 'info');
                saveState();
            }
        }

        function switchToTab(tabId) {
            // Deactivate current tab
            if (currentTabId) {
                const currentTab = document.getElementById(`tab-${currentTabId}`);
                const currentContent = document.getElementById(`tab-content-${currentTabId}`);
                if (currentTab) currentTab.classList.remove('active');
                if (currentContent) currentContent.classList.remove('active');
            }
            
            // Activate new tab
            currentTabId = tabId;
            const newTab = document.getElementById(`tab-${tabId}`);
            const newContent = document.getElementById(`tab-content-${tabId}`);
            
            if (newTab) {
                newTab.classList.add('active');
            } else {
                console.error('Tab element not found:', `tab-${tabId}`);
            }
            
            if (newContent) {
                newContent.classList.add('active');
            } else {
                console.error('Tab content not found:', `tab-content-${tabId}`);
            }
            
            // Update cargo capacity display
            if (globalCargoCapacity > 0) {
                const cargoInput = document.getElementById(`cargoCapacity-${tabId}`);
                if (cargoInput) {
                    cargoInput.value = globalCargoCapacity;
                }
            }
            
            // Update job name input
            const jobNameInput = document.getElementById(`jobName-${tabId}`);
            if (jobNameInput && tabs[tabId]) {
                jobNameInput.value = tabs[tabId].name;
            }
            
            saveState();
        }

        function closeTab(tabId, event) {
            event.stopPropagation();
            
            const tab = tabs[tabId];
            if (!tab) return;
            
            // Ask for confirmation if session is active
            if (tab.sessionActive) {
                const completedCount = tab.materials.filter(m => m.needed <= 0).length;
                const totalCount = tab.materials.length;
                
                if (!confirm(`Close job "${tab.name}"?\n\nThis job has ${completedCount}/${totalCount} materials completed.\n\nAll progress will be lost!`)) {
                    return;
                }
            }
            
            // Remove tab from UI
            document.getElementById(`tab-${tabId}`).remove();
            document.getElementById(`tab-content-${tabId}`).remove();
            
            // Remove tab data
            delete tabs[tabId];
            
            // Switch to another tab if this was the current tab
            if (currentTabId === tabId) {
                const remainingTabs = Object.keys(tabs);
                if (remainingTabs.length > 0) {
                    switchToTab(parseInt(remainingTabs[0]));
                } else {
                    currentTabId = null;
                    // Create a new tab if no tabs remain
                    createNewTab();
                }
            }
            
            saveState();
        }

        // Enhanced State Management
        function saveState() {
            const state = {
                tabs: tabs,
                currentTabId: currentTabId,
                globalCargoCapacity: globalCargoCapacity,
                nextTabId: nextTabId,
                timestamp: new Date().toISOString()
            };
            localStorage.setItem('sonderOS_enhanced_state', JSON.stringify(state));
        }

        function loadState() {
            try {
                const savedState = localStorage.getItem('sonderOS_enhanced_state');
                if (savedState) {
                    const state = JSON.parse(savedState);
                    
                    tabs = state.tabs || {};
                    currentTabId = state.currentTabId || null;
                    globalCargoCapacity = state.globalCargoCapacity || 0;
                    nextTabId = state.nextTabId || 1;
                    
                    // Restore tabs UI
                    const tabsHeader = document.getElementById('tabsHeader');
                    const tabContents = document.getElementById('tabContents');
                    
                    // Clear existing content except new tab button
                    const newTabBtn = tabsHeader.querySelector('.new-tab-btn');
                    tabsHeader.innerHTML = '';
                    tabsHeader.appendChild(newTabBtn);
                    tabContents.innerHTML = '';
                    
                    // Recreate tabs
                    for (const [tabId, tabData] of Object.entries(tabs)) {
                        const id = parseInt(tabId);
                        
                        // Create tab UI
                        const tabElement = document.createElement('div');
                        tabElement.className = 'tab';
                        tabElement.id = `tab-${id}`;
                        tabElement.innerHTML = `
                            <span id="tab-name-${id}">${tabData.name}</span>
                            <button class="tab-close" onclick="closeTab(${id}, event)">×</button>
                        `;
                        tabElement.onclick = (e) => {
                            if (e.target.className !== 'tab-close') {
                                switchToTab(id);
                            }
                        };
                        tabsHeader.insertBefore(tabElement, newTabBtn);
                        
                        // Create tab content
                        tabContents.insertAdjacentHTML('beforeend', createTabContentHTML(id));
                        
                        // Wait for DOM to process before restoring state
                        setTimeout(() => {
                            // Restore tab state
                            if (tabData.sessionActive) {
                                const inputSection = document.getElementById(`inputSection-${id}`);
                                const statsSection = document.getElementById(`statsSection-${id}`);
                                const materialsSection = document.getElementById(`materialsSection-${id}`);
                                const actionButtons = document.getElementById(`actionButtons-${id}`);
                                const confirmBtn = document.getElementById(`confirmBtn-${id}`);
                                const scrubberText = document.getElementById(`scrubber-text-${id}`);
                                
                                if (inputSection) inputSection.style.display = 'none';
                                if (statsSection) statsSection.style.display = 'grid';
                                if (materialsSection) materialsSection.style.display = 'block';
                                if (actionButtons) actionButtons.style.display = 'flex';
                                if (confirmBtn) confirmBtn.disabled = false;
                                if (scrubberText) scrubberText.textContent = 'SCRUB COMPLETE';
                                
                                renderMaterials(id);
                                updateStats(id);
                            }
                            
                            renderActivityLog(id);
                            
                            // Set cargo capacity
                            if (globalCargoCapacity > 0) {
                                const cargoInput = document.getElementById(`cargoCapacity-${id}`);
                                if (cargoInput) {
                                    cargoInput.value = globalCargoCapacity;
                                }
                            }
                            
                            // Set job name in input field
                            const jobNameInput = document.getElementById(`jobName-${id}`);
                            if (jobNameInput) {
                                jobNameInput.value = tabData.name;
                            }
                        }, 10);
                    }
                    
                    // Switch to current tab after a delay to ensure all content is loaded
                    setTimeout(() => {
                        if (currentTabId && tabs[currentTabId]) {
                            switchToTab(currentTabId);
                        } else if (Object.keys(tabs).length > 0) {
                            switchToTab(parseInt(Object.keys(tabs)[0]));
                        }
                    }, 50);
                    
                    return true;
                }
            } catch (e) {
                console.error('Error loading saved state:', e);
                localStorage.removeItem('sonderOS_enhanced_state');
            }
            return false;
        }

        function saveCargoCapacity(tabId) {
            const input = document.getElementById(`cargoCapacity-${tabId}`);
            globalCargoCapacity = parseInt(input.value) || 0;
            
            // Update all other tab inputs
            for (const otherTabId of Object.keys(tabs)) {
                if (parseInt(otherTabId) !== tabId) {
                    const otherInput = document.getElementById(`cargoCapacity-${otherTabId}`);
                    if (otherInput) {
                        otherInput.value = globalCargoCapacity;
                    }
                }
            }
            
            saveState();
            
            if (globalCargoCapacity > 0) {
                logActivity(tabId, `Global cargo capacity set to ${globalCargoCapacity} tons`, 'info');
            }
        }

        // Activity Logging
        function logActivity(tabId, message, type = 'info') {
            if (!tabs[tabId]) return;
            
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] ${message}`;
            
            tabs[tabId].activityLog.unshift({ message: logEntry, type });
            if (tabs[tabId].activityLog.length > 100) {
                tabs[tabId].activityLog = tabs[tabId].activityLog.slice(0, 100);
            }
            
            renderActivityLog(tabId);
            saveState();
        }

        function renderActivityLog(tabId) {
            if (!tabs[tabId]) return;
            
            const logContainer = document.getElementById(`activityLog-${tabId}`);
            if (!logContainer) return;
            
            logContainer.innerHTML = '';
            
            tabs[tabId].activityLog.forEach(entry => {
                const logDiv = document.createElement('div');
                logDiv.className = `log-entry ${entry.type}`;
                logDiv.textContent = entry.message;
                logContainer.appendChild(logDiv);
            });
        }

        // Material Management with Undo
        function addUndoHistory(tabId, materialId, action, oldValue, newValue) {
            const material = tabs[tabId].materials.find(m => m.id === materialId);
            if (!material) return;
            
            if (!material.undoHistory) {
                material.undoHistory = [];
            }
            
            material.undoHistory.unshift({
                action: action,
                oldNeeded: oldValue.needed,
                oldAllocated: oldValue.allocated,
                newNeeded: newValue.needed,
                newAllocated: newValue.allocated,
                timestamp: new Date().toISOString()
            });
            
            // Keep only last 10 undo actions per material
            if (material.undoHistory.length > 10) {
                material.undoHistory = material.undoHistory.slice(0, 10);
            }
        }

        function undoLastAllocation(tabId, materialId) {
            if (!tabs[tabId]) return;
            
            const material = tabs[tabId].materials.find(m => m.id === materialId);
            if (!material || !material.undoHistory || material.undoHistory.length === 0) {
                logActivity(tabId, `No undo history for ${material ? material.name : 'unknown material'}`, 'warning');
                return;
            }
            
            const lastAction = material.undoHistory.shift();
            
            // Restore previous values
            material.needed = lastAction.oldNeeded;
            material.allocated = lastAction.oldAllocated;
            
            logActivity(tabId, `UNDO: ${material.name} restored to ${lastAction.oldAllocated} allocated, ${lastAction.oldNeeded} needed`, 'undo');
            
            renderMaterials(tabId);
            updateStats(tabId);
            saveState();
        }

        // Data Scrubbing
        function runDataScrubber(tabId) {
            console.log('runDataScrubber called for tab:', tabId);
            
            if (!tabs[tabId]) {
                console.error('Tab not found:', tabId);
                return;
            }
            
            const pasteArea = document.getElementById(`commoditiesPaste-${tabId}`);
            if (!pasteArea) {
                console.error('Paste area not found for tab:', tabId);
                return;
            }
            
            const rawData = pasteArea.value.trim();
            console.log('Raw data length:', rawData.length);
            
            if (!rawData) {
                logActivity(tabId, 'Error: No data to scrub. Please paste commodities list first.', 'warning');
                return;
            }
            
            if (tabs[tabId].scrubberActive) {
                console.log('Scrubber already active for tab:', tabId);
                return;
            }
            
            tabs[tabId].scrubberActive = true;
            const scrubberBtn = document.getElementById(`scrubberBtn-${tabId}`);
            const scrubberText = document.getElementById(`scrubber-text-${tabId}`);
            
            scrubberBtn.classList.add('active');
            scrubberText.textContent = 'SCRUBBING DATA...';
            scrubberBtn.disabled = true;
            
            logActivity(tabId, 'Data scrubber initiated - parsing commodities list', 'info');
            
            // Simulate scrubbing process with progress
            let progress = 0;
            const scrubberInterval = setInterval(() => {
                progress += 25;
                scrubberText.textContent = `SCRUBBING... ${progress}%`;
                
                if (progress >= 100) {
                    clearInterval(scrubberInterval);
                    
                    // Parse the data
                    const parsedMaterials = parseRawData(tabId, rawData);
                    
                    if (parsedMaterials.length > 0) {
                        tabs[tabId].materials = parsedMaterials;
                        tabs[tabId].sessionActive = true;
                        
                        // Increment usage count on successful scrub
                        incrementUsageCount();
                        
                        saveState();
                        
                        scrubberText.textContent = 'SCRUB COMPLETE';
                        scrubberBtn.classList.remove('active');
                        
                        // Show materials section
                        document.getElementById(`statsSection-${tabId}`).style.display = 'grid';
                        document.getElementById(`materialsSection-${tabId}`).style.display = 'block';
                        document.getElementById(`actionButtons-${tabId}`).style.display = 'flex';
                        document.getElementById(`confirmBtn-${tabId}`).disabled = false;
                        
                        renderMaterials(tabId);
                        updateStats(tabId);
                        
                        logActivity(tabId, `Successfully parsed ${parsedMaterials.length} materials from input`, 'success');
                        
                        // Hide input section
                        document.getElementById(`inputSection-${tabId}`).style.display = 'none';
                        
                    } else {
                        scrubberText.textContent = 'SCRUB FAILED';
                        logActivity(tabId, 'Error: Could not parse any valid materials from input', 'warning');
                        
                        setTimeout(() => {
                            scrubberText.textContent = 'SCRUB & PARSE DATA';
                            scrubberBtn.disabled = false;
                            tabs[tabId].scrubberActive = false;
                        }, 2000);
                    }
                }
            }, 500);
        }

        // Centralized quantity parsing function - strips ALL punctuation except 'k' suffix
        function parseQuantity(quantityStr) {
            if (!quantityStr) return 0;
            
            let cleanStr = quantityStr.toString().trim();
            
            // Handle 'k' or 'K' suffix (thousands) - check this BEFORE stripping punctuation
            const kMatch = cleanStr.match(/(\d+(?:[,.]\d+)?)\s*[kK](?:\s*[tT](?:ons?)?)?/i);
            if (kMatch) {
                // Strip punctuation from the number part and multiply by 1000
                const baseNumber = kMatch[1].replace(/[^\d]/g, '');
                return parseInt(baseNumber) * 1000;
            }
            
            // Strip ALL punctuation except digits (includes commas, periods, colons, pipes, etc.)
            cleanStr = cleanStr.replace(/[^\d]/g, '');
            
            // Return parsed integer or 0 if invalid
            return parseInt(cleanStr) || 0;
        }

        function parseRawData(tabId, rawData) {
            // Check for Consolidated Contract format
            if (rawData.includes('ALL MATERIALS:') && rawData.includes('===')) {
                return parseConsolidatedContract(tabId, rawData);
            }
            
            // Check if this is a Discord ticket format
            if (rawData.includes('ITEMS:') || rawData.includes('CONTRACT:')) {
                return parseDiscordTicket(tabId, rawData);
            }
            
            // Check for 3-column pipe format (Item | Qty | Price)
            if (rawData.includes('|') && (rawData.includes('Qty') || rawData.includes('Buy Price'))) {
                return parseThreeColumnFormat(tabId, rawData);
            }
            
            // Original parsing for other formats
            const lines = rawData.split('\n').map(line => line.trim()).filter(line => line);
            const parsedMaterials = [];
            let id = 1;
            
            for (const line of lines) {
                // Try different separator patterns
                let match = null;
                let name = '';
                let quantity = 0;
                
                // Pattern matching logic using centralized parseQuantity
                match = line.match(/^(.+?):\s*(.+)$/);
                if (match) {
                    name = match[1].trim();
                    quantity = parseQuantity(match[2]);
                } else {
                    match = line.match(/^(.+?)\s*:\s*(.+)$/);
                    if (match) {
                        // Try parsing first part as quantity, second as name
                        const firstPart = parseQuantity(match[1]);
                        if (firstPart > 0) {
                            quantity = firstPart;
                            name = match[2].trim();
                        } else {
                            name = match[1].trim();
                            quantity = parseQuantity(match[2]);
                        }
                    }
                }
                
                if (!match) {
                    match = line.match(/^(.+?),\s*(.+)$/);
                    if (match) {
                        name = match[1].trim();
                        quantity = parseQuantity(match[2]);
                        // If first parse failed, try reverse
                        if (quantity === 0) {
                            const firstPart = parseQuantity(match[1]);
                            if (firstPart > 0) {
                                quantity = firstPart;
                                name = match[2].trim();
                            }
                        }
                    }
                }
                
                if (!match) {
                    match = line.match(/^(.+?)\s*-\s*(.+)$/);
                    if (match) {
                        name = match[1].trim();
                        quantity = parseQuantity(match[2]);
                        // If first parse failed, try reverse
                        if (quantity === 0) {
                            const firstPart = parseQuantity(match[1]);
                            if (firstPart > 0) {
                                quantity = firstPart;
                                name = match[2].trim();
                            }
                        }
                    }
                }
                
                if (!match) {
                    match = line.match(/^(.+?)\s*\|\s*(.+)$/);
                    if (match) {
                        name = match[1].trim();
                        quantity = parseQuantity(match[2]);
                        // If first parse failed, try reverse
                        if (quantity === 0) {
                            const firstPart = parseQuantity(match[1]);
                            if (firstPart > 0) {
                                quantity = firstPart;
                                name = match[2].trim();
                            }
                        }
                    }
                }
                
                if (!match) {
                    match = line.match(/^(.+?)\t+(.+)$/);
                    if (match) {
                        name = match[1].trim();
                        quantity = parseQuantity(match[2]);
                        // If first parse failed, try reverse
                        if (quantity === 0) {
                            const firstPart = parseQuantity(match[1]);
                            if (firstPart > 0) {
                                quantity = firstPart;
                                name = match[2].trim();
                            }
                        }
                    }
                }
                
                if (!match) {
                    match = line.match(/^(.+?)\s{2,}(.+)$/);
                    if (match) {
                        name = match[1].trim();
                        quantity = parseQuantity(match[2]);
                        // If first parse failed, try reverse
                        if (quantity === 0) {
                            const firstPart = parseQuantity(match[1]);
                            if (firstPart > 0) {
                                quantity = firstPart;
                                name = match[2].trim();
                            }
                        }
                    }
                }
                
                if (!match) {
                    match = line.match(/^(.+?)\s+(.+)$/);
                    if (match) {
                        name = match[1].trim();
                        quantity = parseQuantity(match[2]);
                        // If first parse failed, try reverse
                        if (quantity === 0) {
                            const firstPart = parseQuantity(match[1]);
                            if (firstPart > 0) {
                                quantity = firstPart;
                                name = match[2].trim();
                            }
                        }
                    }
                }
                
                if (match && name && quantity > 0) {
                    parsedMaterials.push({
                        id: id++,
                        name: name,
                        needed: quantity,
                        original: quantity,
                        allocated: 0,
                        undoHistory: []
                    });
                    
                    logActivity(tabId, `Parsed: ${name} (${quantity} needed)`, 'info');
                } else {
                    logActivity(tabId, `Warning: Could not parse line: "${line}"`, 'warning');
                }
            }
            
            return parsedMaterials;
        }

        // NEW: Parse Consolidated Contract format
        function parseConsolidatedContract(tabId, rawData) {
            const lines = rawData.split('\n').map(line => line.trim());
            const parsedMaterials = [];
            let id = 1;
            let inMaterialsSection = false;
            let contractInfo = {};
            
            // Extract contract info
            for (const line of lines) {
                if (line.includes('CONSOLIDATED CONTRACT')) {
                    contractInfo.type = 'Consolidated Contract';
                } else if (line.includes('System:')) {
                    contractInfo.system = line.split(':')[1]?.trim();
                } else if (line.includes('Order:')) {
                    contractInfo.order = line.split(':')[1]?.trim();
                } else if (line.includes('Total Tonnage:')) {
                    contractInfo.tonnage = line.split(':')[1]?.trim();
                } else if (line.includes('TOTAL CONTRACT PRICE:')) {
                    contractInfo.price = line.split(':')[1]?.trim();
                }
            }
            
            // Log contract info
            if (contractInfo.type) {
                logActivity(tabId, `Processing: ${contractInfo.type}`, 'info');
                if (contractInfo.system) logActivity(tabId, `System: ${contractInfo.system}`, 'info');
                if (contractInfo.order) logActivity(tabId, `Order: ${contractInfo.order}`, 'info');
                if (contractInfo.tonnage) logActivity(tabId, `Total Tonnage: ${contractInfo.tonnage}`, 'info');
                if (contractInfo.price) logActivity(tabId, `Contract Price: ${contractInfo.price}`, 'info');
                
                // Update tab name based on order
                if (contractInfo.order) {
                    tabs[tabId].name = contractInfo.order;
                    const tabNameElement = document.getElementById(`tab-name-${tabId}`);
                    if (tabNameElement) {
                        tabNameElement.textContent = contractInfo.order;
                    }
                    
                    // Update job name input
                    const jobNameInput = document.getElementById(`jobName-${tabId}`);
                    if (jobNameInput) {
                        jobNameInput.value = contractInfo.order;
                    }
                }
            }
            
            for (const line of lines) {
                // Start processing materials after "ALL MATERIALS:" section
                if (line.includes('ALL MATERIALS:')) {
                    inMaterialsSection = true;
                    continue;
                }
                
                if (!inMaterialsSection) continue;
                
                // Skip category headers, separators, and header lines
                if (line.startsWith('===') || 
                    line.includes('Item') || 
                    line.includes('---') || 
                    line.includes('Qty') ||
                    line.trim() === '' ||
                    line.startsWith('=')) {
                    continue;
                }
                
                // Parse material lines (format: Material Name | Quantity)
                const itemMatch = line.match(/^(.+?)\s*\|\s*(.+)$/);
                
                if (itemMatch) {
                    let name = itemMatch[1].trim();
                    const quantity = parseQuantity(itemMatch[2]);
                    
                    // Handle arrow notation (→) for alternative names
                    const arrowMatch = name.match(/^(.+?)\s*\(→(.+?)\)$/);
                    if (arrowMatch) {
                        name = arrowMatch[2].trim(); // Use the name after the arrow
                        logActivity(tabId, `Using alternative name: ${arrowMatch[1].trim()} → ${name}`, 'info');
                    }
                    
                    if (name && quantity > 0) {
                        parsedMaterials.push({
                            id: id++,
                            name: name,
                            needed: quantity,
                            original: quantity,
                            allocated: 0,
                            undoHistory: []
                        });
                        
                        logActivity(tabId, `Parsed: ${name} (${quantity} needed)`, 'info');
                    }
                } else {
                    // Log lines that couldn't be parsed for debugging
                    if (line.length > 0 && !line.startsWith('=') && !line.includes('--')) {
                        logActivity(tabId, `Skipped line: "${line}"`, 'warning');
                    }
                }
            }
            
            if (parsedMaterials.length > 0) {
                logActivity(tabId, `Successfully parsed ${parsedMaterials.length} items from consolidated contract`, 'success');
            }
            
            return parsedMaterials;
        }

        function parseThreeColumnFormat(tabId, rawData) {
            const lines = rawData.split('\n').map(line => line.trim()).filter(line => line);
            const parsedMaterials = [];
            let id = 1;
            
            logActivity(tabId, 'Detected 3-column pipe format (Item | Qty | Price)', 'info');
            
            for (const line of lines) {
                if (line.includes('Item') && line.includes('Qty') ||
                    line.includes('---') ||
                    line.includes('===') ||
                    line.startsWith('=') ||
                    line.trim() === '') {
                    continue;
                }
                
                const match = line.match(/^(.+?)\s*\|\s*(.+?)\s*\|\s*(.+)$/);
                
                if (match) {
                    const name = match[1].trim();
                    const quantity = parseQuantity(match[2]);
                    const price = parseQuantity(match[3]);
                    
                    if (name && quantity > 0) {
                        parsedMaterials.push({
                            id: id++,
                            name: name,
                            needed: quantity,
                            original: quantity,
                            allocated: 0,
                            undoHistory: []
                        });
                        
                        logActivity(tabId, `Parsed: ${name} (${quantity} needed @ ${price} credits)`, 'info');
                    }
                } else {
                    if (line.length > 0) {
                        logActivity(tabId, `Skipped line: "${line}"`, 'warning');
                    }
                }
            }
            
            if (parsedMaterials.length > 0) {
                logActivity(tabId, `Successfully parsed ${parsedMaterials.length} items from 3-column format`, 'success');
            }
            
            return parsedMaterials;
        }

        function parseDiscordTicket(tabId, rawData) {
            const lines = rawData.split('\n');
            const parsedMaterials = [];
            let id = 1;
            let inItemsSection = false;
            let contractInfo = {};
            
            // Extract contract info
            for (const line of lines) {
                if (line.includes('CONTRACT:')) {
                    contractInfo.contract = line.split(':')[1]?.trim();
                } else if (line.includes('System:')) {
                    contractInfo.system = line.split(':')[1]?.trim();
                } else if (line.includes('Order:')) {
                    contractInfo.order = line.split(':')[1]?.trim();
                } else if (line.includes('Total Tonnage:')) {
                    contractInfo.tonnage = line.split(':')[1]?.trim();
                }
            }
            
            // Log contract info
            if (contractInfo.contract) {
                logActivity(tabId, `Processing ticket: ${contractInfo.contract}`, 'info');
                if (contractInfo.system) logActivity(tabId, `System: ${contractInfo.system}`, 'info');
                if (contractInfo.order) logActivity(tabId, `Order: ${contractInfo.order}`, 'info');
                if (contractInfo.tonnage) logActivity(tabId, `Total Tonnage: ${contractInfo.tonnage}`, 'info');
                
                // Update tab name based on contract
                tabs[tabId].name = contractInfo.contract;
                const tabNameElement = document.getElementById(`tab-name-${tabId}`);
                if (tabNameElement) {
                    tabNameElement.textContent = contractInfo.contract;
                }
            }
            
            for (const line of lines) {
                if (line.includes('ITEMS:')) {
                    inItemsSection = true;
                    continue;
                }
                
                if (!inItemsSection || 
                    line.includes('Item') || 
                    line.includes('---') || 
                    line.includes('===') ||
                    line.trim() === '') {
                    continue;
                }
                
                const itemMatch = line.match(/^(.+?)\s*\|\s*(.+?)\s*\|\s*(.+)$/);
                
                if (itemMatch) {
                    const name = itemMatch[1].trim();
                    const quantity = parseQuantity(itemMatch[2]);
                    
                    if (name && quantity > 0) {
                        parsedMaterials.push({
                            id: id++,
                            name: name,
                            needed: quantity,
                            original: quantity,
                            allocated: 0,
                            undoHistory: []
                        });
                        
                        logActivity(tabId, `Parsed: ${name} (${quantity} needed)`, 'info');
                    }
                }
            }
            
            if (parsedMaterials.length > 0) {
                logActivity(tabId, `Successfully parsed ${parsedMaterials.length} items from Discord ticket`, 'success');
            }
            
            return parsedMaterials;
        }

        // Material Rendering and Control
        function renderMaterials(tabId) {
            if (!tabs[tabId]) return;
            
            const grid = document.getElementById(`materialsGrid-${tabId}`);
            if (!grid) return;
            
            grid.innerHTML = '';
            
            tabs[tabId].materials.forEach(material => {
                const remaining = material.needed;
                const status = remaining <= 0 ? 'complete' : 
                              material.allocated > 0 ? 'partial' : 'needed';
                
                const itemDiv = document.createElement('div');
                itemDiv.className = `material-item ${status}`;
                
                // Determine cargo button allocation amount and text
                const cargoAllocation = Math.min(globalCargoCapacity, remaining);
                const cargoButtonDisabled = globalCargoCapacity <= 0 || remaining <= 0;
                const cargoButtonText = globalCargoCapacity > 0 ? `${cargoAllocation}T` : 'Set Cargo';
                
                // Check if undo is available
                const undoAvailable = material.undoHistory && material.undoHistory.length > 0;
                
                itemDiv.innerHTML = `
                    <div class="material-name">${material.name}</div>
                    <div class="material-progress">
                        Need: ${material.needed}<br>
                        Allocated: ${material.allocated}
                    </div>
                    <div class="material-controls">
                        <input type="number" class="material-input" 
                               value="0" min="0" max="${remaining}"
                               onkeypress="handleEnterKey(event, ${tabId}, ${material.id}, this)"
                               placeholder="0">
                        <button class="cargo-btn" ${cargoButtonDisabled ? 'disabled' : ''} 
                                onclick="allocateCargoCapacity(${tabId}, ${material.id})">${cargoButtonText}</button>
                        <button class="undo-btn" ${undoAvailable ? '' : 'disabled'} 
                                onclick="undoLastAllocation(${tabId}, ${material.id})">UNDO</button>
                    </div>
                    <div class="status-indicator status-${status}"></div>
                `;
                
                grid.appendChild(itemDiv);
            });
        }

        function handleEnterKey(event, tabId, materialId, inputElement) {
            if (event.key === 'Enter') {
                const quantity = parseInt(inputElement.value) || 0;
                
                if (quantity > 0) {
                    allocateMaterial(tabId, materialId, quantity);
                    inputElement.value = '0';
                    inputElement.focus();
                }
            }
        }

        function allocateCargoCapacity(tabId, materialId) {
            if (!tabs[tabId]) return;
            
            if (globalCargoCapacity <= 0) {
                logActivity(tabId, 'Error: Set your cargo capacity first', 'warning');
                return;
            }
            
            const material = tabs[tabId].materials.find(m => m.id === materialId);
            if (!material) return;
            
            const allocatable = Math.min(globalCargoCapacity, material.needed);
            
            if (allocatable <= 0) {
                logActivity(tabId, `${material.name} already fully allocated`, 'warning');
                return;
            }
            
            // Store undo history
            addUndoHistory(tabId, materialId, 'cargo_allocation', 
                          { needed: material.needed, allocated: material.allocated },
                          { needed: material.needed - allocatable, allocated: material.allocated + allocatable });
            
            // Allocate the cargo capacity amount
            material.needed -= allocatable;
            material.allocated += allocatable;
            
            // Log the allocation
            logActivity(tabId, `Full cargo load: ${allocatable}T ${material.name} (Remaining: ${material.needed})`, 'allocation');
            
            // Re-render and update stats
            renderMaterials(tabId);
            updateStats(tabId);
            saveState();
            
            // Check if material is complete
            if (material.needed <= 0) {
                logActivity(tabId, `✓ ${material.name} COMPLETE (${material.allocated}/${material.original})`, 'success');
            }
        }

        function allocateMaterial(tabId, materialId, quantity) {
            if (!tabs[tabId]) return;
            
            const material = tabs[tabId].materials.find(m => m.id === materialId);
            if (!material) return;
            
            const allocatable = Math.min(quantity, material.needed);
            
            if (allocatable <= 0) {
                logActivity(tabId, `Warning: ${material.name} already fully allocated`, 'warning');
                return;
            }
            
            // Store undo history
            addUndoHistory(tabId, materialId, 'manual_allocation', 
                          { needed: material.needed, allocated: material.allocated },
                          { needed: material.needed - allocatable, allocated: material.allocated + allocatable });
            
            // Subtract from needed and add to allocated
            material.needed -= allocatable;
            material.allocated += allocatable;
            
            // Log the allocation
            logActivity(tabId, `Allocated ${allocatable} ${material.name} (Remaining: ${material.needed})`, 'allocation');
            
            // Re-render and update stats
            renderMaterials(tabId);
            updateStats(tabId);
            saveState();
            
            // Check if material is complete
            if (material.needed <= 0) {
                logActivity(tabId, `✓ ${material.name} COMPLETE (${material.allocated}/${material.original})`, 'success');
            }
        }

        function updateStats(tabId) {
            if (!tabs[tabId]) return;
            
            const materials = tabs[tabId].materials;
            const totalItems = materials.length;
            const totalNeeded = materials.reduce((sum, m) => sum + m.needed, 0);
            const totalAllocated = materials.reduce((sum, m) => sum + m.allocated, 0);
            const totalOriginal = materials.reduce((sum, m) => sum + m.original, 0);
            
            // Calculate completion rate based on tonnage, not item count
            const completionRate = totalOriginal > 0 ? Math.round((totalAllocated / totalOriginal) * 100) : 0;

            const totalItemsEl = document.getElementById(`totalItems-${tabId}`);
            const totalNeededEl = document.getElementById(`totalNeeded-${tabId}`);
            const totalAllocatedEl = document.getElementById(`totalAllocated-${tabId}`);
            const completionRateEl = document.getElementById(`completionRate-${tabId}`);
            
            if (totalItemsEl) totalItemsEl.textContent = totalItems;
            if (totalNeededEl) totalNeededEl.textContent = totalNeeded;
            if (totalAllocatedEl) totalAllocatedEl.textContent = totalAllocated;
            if (completionRateEl) completionRateEl.textContent = completionRate + '%';
        }

        function finalizeSession(tabId) {
            if (!tabs[tabId] || !tabs[tabId].sessionActive) return;
            
            const materials = tabs[tabId].materials;
            const completedCount = materials.filter(m => m.needed <= 0).length;
            const totalCount = materials.length;
            
            if (confirm(`Finalize session for "${tabs[tabId].name}"?\n\nCompleted: ${completedCount}/${totalCount} materials\n\nThis will close this job tab.`)) {
                
                // Log final session summary
                logActivity(tabId, `=== SESSION FINALIZED ===`, 'success');
                logActivity(tabId, `Completed materials: ${completedCount}/${totalCount}`, 'success');
                
                materials.forEach(material => {
                    if (material.allocated > 0) {
                        logActivity(tabId, `Final: ${material.name} - ${material.allocated}/${material.original} allocated`, 'info');
                    }
                });
                
                logActivity(tabId, `=== SESSION END ===`, 'success');
                
                // Close the tab after a brief delay
                setTimeout(() => {
                    closeTab(tabId, { stopPropagation: () => {} });
                }, 2000);
            }
        }

        function clearSession(tabId) {
            if (!tabs[tabId]) return;
            
            tabs[tabId].materials = [];
            tabs[tabId].sessionActive = false;
            tabs[tabId].activityLog = [];
            
            // Reset UI
            document.getElementById(`commoditiesPaste-${tabId}`).value = '';
            document.getElementById(`inputSection-${tabId}`).style.display = 'block';
            document.getElementById(`statsSection-${tabId}`).style.display = 'none';
            document.getElementById(`materialsSection-${tabId}`).style.display = 'none';
            document.getElementById(`actionButtons-${tabId}`).style.display = 'none';
            
            // Reset buttons
            document.getElementById(`scrubberBtn-${tabId}`).disabled = false;
            document.getElementById(`confirmBtn-${tabId}`).disabled = true;
            document.getElementById(`scrubber-text-${tabId}`).textContent = 'SCRUB & PARSE DATA';
            
            tabs[tabId].scrubberActive = false;
            
            logActivity(tabId, 'Session cleared - ready for new commodities list', 'info');
            saveState();
        }

        function exportData(tabId) {
            if (!tabs[tabId]) return;
            
            const tab = tabs[tabId];
            const data = {
                tabName: tab.name,
                timestamp: new Date().toISOString(),
                sessionSummary: {
                    totalMaterials: tab.materials.length,
                    completedMaterials: tab.materials.filter(m => m.needed <= 0).length,
                    totalAllocated: tab.materials.reduce((sum, m) => sum + m.allocated, 0),
                    totalOriginal: tab.materials.reduce((sum, m) => sum + m.original, 0)
                },
                materials: tab.materials,
                activityLog: tab.activityLog
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `sonderOS_${tab.name.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            logActivity(tabId, 'Session data exported successfully', 'success');
        }

        // Initialize
        function initializeApp() {
            console.log('Initializing SonderOS Enhanced...');
            
            try {
                // Load usage count first
                loadUsageCount();
                
                const restored = loadState();
                if (!restored) {
                    console.log('No saved state found, creating new tab...');
                    createNewTab();
                } else {
                    console.log('Restored previous state with', Object.keys(tabs).length, 'tabs');
                }
            } catch (error) {
                console.error('Error during initialization:', error);
                // Fallback: create a new tab
                createNewTab();
            }
        }

        // Multiple initialization methods to ensure it works in all environments
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeApp);
        } else if (document.readyState === 'interactive' || document.readyState === 'complete') {
            initializeApp();
        }

        window.addEventListener('load', () => {
            // Final fallback: ensure at least one tab exists
            setTimeout(() => {
                if (Object.keys(tabs).length === 0) {
                    console.log('Fallback: Creating tab after window load');
                    createNewTab();
                }
            }, 100);
        });
    </script>
</body>
</html>
